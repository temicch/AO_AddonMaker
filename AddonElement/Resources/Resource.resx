<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Desc_BackLayer" xml:space="preserve">
    <value>Слой для отображения нижней части текстуры</value>
  </data>
  <data name="Desc_BindSections" xml:space="preserve">
    <value>Список реакций на клавиатурные нажатия</value>
  </data>
  <data name="Desc_Enabled" xml:space="preserve">
    <value>Доступен ли виджет и все его дочерние виджеты для реакций. Может влиять на внешний вид (виджет "засеривается"). По умолчанию true</value>
  </data>
  <data name="Desc_Fade" xml:space="preserve">
    <value>Визуальная прозрачность виджета. По умолчанию 1.0f - непрозрачен</value>
  </data>
  <data name="Desc_ForceReactionOnPointing" xml:space="preserve">
    <value>Уведомление о наведении на виджет вне зависимости от его доступности для кликов. (Использовать только при сильной необходимости - потребляет много ресурсов.)</value>
  </data>
  <data name="Desc_ForceWheel" xml:space="preserve">
    <value>Игнорировать PickChildrenOnly при скролировании колесом мыши и наведении. Всегда обрабатывать реакцию скролла колесом мыши</value>
  </data>
  <data name="Desc_FrontLayer" xml:space="preserve">
    <value>Слой для отображения верхней части текстуры</value>
  </data>
  <data name="Desc_IgnoreDblClick" xml:space="preserve">
    <value>Игнорировать двойной клик мышью для виджета и для его детей</value>
  </data>
  <data name="Desc_IsProtected" xml:space="preserve">
    <value>Запрещать ли пользовательским аддонам операции с виджетом. По умолчанию false</value>
  </data>
  <data name="Desc_Name" xml:space="preserve">
    <value>Системное название виджета</value>
  </data>
  <data name="Desc_PickChildrenOnly" xml:space="preserve">
    <value>Обрабатывать мышиные реакции только для детей этого виджета, игнорируя сам виджет</value>
  </data>
  <data name="Desc_PickMask" xml:space="preserve">
    <value>Черно-белая текстура (по степеням 2) для задания активной (белые пиксели) области для кликов мышью. Нужно вручную выставлять mipSW = 0 при экспорте</value>
  </data>
  <data name="Desc_Placement" xml:space="preserve">
    <value>Описание расположение виджета</value>
  </data>
  <data name="Desc_Priority" xml:space="preserve">
    <value>Приоритет отображения (также влияет на обработку мышиных событий) виджета в списке виджетов своего родителя. То есть с помощью этого поля можно сформировать иерархию отображения виджетов всего аддона</value>
  </data>
  <data name="Desc_ReactionOnPointing" xml:space="preserve">
    <value>Уведомление о наведении на виджет. (Кроме виджетов со специальной обработкой - кнопок и т.д.)</value>
  </data>
  <data name="Desc_ReactionWheelDown" xml:space="preserve">
    <value>Уведомление о прокрутке колёсика мыши вниз</value>
  </data>
  <data name="Desc_ReactionWheelUp" xml:space="preserve">
    <value>Уведомление о прокрутке колёсика мыши вверх</value>
  </data>
  <data name="Desc_SoundHide" xml:space="preserve">
    <value>Звук на скрытие виджета</value>
  </data>
  <data name="Desc_SoundShow" xml:space="preserve">
    <value>Звук на начатое отображение виджета</value>
  </data>
  <data name="Desc_TabOrder" xml:space="preserve">
    <value>Задаёт порядок обхода контролов по клавише Tab. По умолчанию 0(не учавствует в обходе). Для участия в обходе значение должно быть больше 0</value>
  </data>
  <data name="Desc_TextureMask" xml:space="preserve">
    <value>Текстура с альфой. Используется для задания маски, по которой будет обрезана основная текстура данного контрола и всех его детей</value>
  </data>
  <data name="Desc_TransparentInput" xml:space="preserve">
    <value>Является ли виджет прозрачным для ввода. По умолчанию false</value>
  </data>
  <data name="Desc_Visible" xml:space="preserve">
    <value>Виден ли виджет. По умолчанию true. если виджет не виден, то он недоступен и для реакций</value>
  </data>
  <data name="Desc_Widgets" xml:space="preserve">
    <value>Дочерние виджеты. Почти каждый виджет может содержать дочерние виджеты, за исключением особых случаев типа слайдера и т.п. Дочерние виджеты отображаются поверх родителя и перехватывают реакции (если они объявлены и на них подписаны обработчики) раньше родительского виджета за исключением особых случаев</value>
  </data>
  <data name="Desc_СlipContent" xml:space="preserve">
    <value>Нужно ли обрезать содержимое, включая дочерние виджеты, по границам данного. По умолчанию false</value>
  </data>
</root>